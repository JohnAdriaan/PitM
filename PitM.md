# Pi in the Middle (PitM)
This is the design/progress document for the PitM project.

## Inspiration
My Internet Service Provider (ISP) has been giving me problems.

### _The Problem_
I'd be browsing fine, but then I'd click a link and the "loading" progress bar would stall early on. The page would never load.

When I talked to the ISP support people, they'd blame it on my setup, since their diagnostics showed "no problem!"
I tried diagnosing the problem for myself using various network analysis tools - and the most telling was `nslookup`.

### _The Diagnosis_
This tool's full name is "Name Server lookup".
It asks the ISP's Name Server for the translation between the human-readable website name to its computer address.
For example, before `www.google.com.au` can be accessed, the browser has to get it converted to its IP address `172.217.25.131`.
This operation is performed (usually) by your ISP, and your browser cannot do anything until the translation is performed.

When I ran `nslookup`, it would usually respond instantly. But occasionally it would pause for a while and then reply `Timed out`.
If the browser experiences this, it will re-submit the request, so I did too - but there'd be long periods of time when the Name Server simply timed out.

However, since this was intermittent, I couldn't go back to my ISP with any proof.
So I decided to log the packets that were being generated by my surfing, and provide that to my ISP to get them to resolve the issue.

### _The Solution_
But how to log the packets?
I realised that my Internet setup was an ADSL modem connected to my phone line, with an Ethernet cable to my WiFi router.
All I had to do was put a logging device between the router and modem! However, it turns out that these analysers are expensive.
But I had some time on my hands, a spare Raspberry Pi 3 Model B, and a spare USB/Ethernet adapter. To work!

### _The Name_
I decided to name this project PitM, "Pi in the Middle", since it's a perfect example of the quintessential cryptographic scenario dubbed MitM, "Man in the Middle".
While researching this name though (I didn't want to step on anyone else's project!) I found out that "PITM" also stands for
["Prove It To Me"](https://acronyms.thefreedictionary.com/PITM). Perfect!

## Design
A [Raspberry Pi](https://www.raspberrypi.org) is a small box that you normally connect to a monitor, keyboard and mouse to use.
But it also works in "headless" mode - simply power it up with nothing connected and it will start working anyway.
Thus I could install it between the WiFi router and the ADSL modem and leave it permanently connected, processing the packets as they passed back and forth.

### _Issues_
- The biggest drawback would be that my Internet speed could slow down.
It would be imperative for the solution to work as fast as possible, with as little overhead as possible, to lessen the impact.
- To that end, I'd want the logger to log only the packets of interest, rather than everything passing through.
- I'd want to be able to monitor its progress without having to connect a monitor, keyboard and mouse every time.
- Preferably, I'd want to be able to reconfigure it on the fly too, without having to change the program code.

### _Realisations_
- By writing the code in C/C++ rather than a higher-level language such as Python, the code would be as fast as possible.
- By parsing the packets as they passed through, the decision as to which packets to log could be made.
This parsing would have to be very cursory, however - again, to minimise latency.
- The Raspberry Pi has a single Ethenet port, but it also has USB ports into which I could plug a USB/Ethernet adapter.
However, both of these ports would be dedicated to the pass-through role, unavailable for use with remote monitoring.
Luckily, the Pi 3 also has a WiFi on board, so I could connect to _that_ to monitor what the Pi was doing.
- And with extra work, I could use that WiFi connection to reconfigure the Pi on the fly as well.

### _Resolutions_
- I'd write the code in C++, using Linux libraries for socket access and multithreading.
The Raspberry Pi 3 has 4 cores, and the system wouldn't be doing much other than running this program, so latency should be minimal.
- To minimise packet parsing, I would only look for broad categories of packets: DNS packets, or Web packets, or whatever.
I wouldn't allow sophisticated decision making - I'd leave that to the packet viewer that was displaying the captured packets.
To that end, I'd log the packets in the libpcap packet capture format, allowing the popular WireShark (Ethereal) program to display them.
- The most obvious mechanism for remote monitoring of a system is through a Web page.
Point a browser at the system, and the system's current status can be viewed.
However, a complete Web server infrastructure is quite intensive, and requires a significant amount of coding to pass data between programs and the server.
By writing a simple Web server as part of _this_ program, I could "serve up" the various "pages" of status as required.
- And with a bit more work, that same Web server could be used to reconfigure the program.

## Modules
- `[ ]` Framework
   - `[ ]` main()
   - `[ ]` Threads
- `[ ]` Configuration
   - `[ ]` Which interfaces to use for what
   - `[ ]` Which protocols to process:
      - `[ ]` Ethernet
      - `[ ]` PPPoE
      - `[ ]` PPPoA
- `[ ]` Packet pass-through
   - `[ ]` Statistics accumulation
   - `[ ]` Packet logging using pcap format
- `[ ]` Web interface
   - `[ ]` HTML Parser
      - `[ ]` HTML5 server-side updates?
   - `[ ]` Status page
   - `[ ]` Statistics page
   - `[ ]` Log download page
   - `[ ]` Configuration page

## Testing
