//
// Queue.tt
//
// Usage:
// I wanted two different kinds of Queues, each with two different kinds of Pop() operation.
// The Queue types were either intra-thread or inter-thread (thus thread-safe);
// The Pop() types were either Wait() or return with nothing.
// Since this was going to be a template<> anyway, the first problem was solved by defining
// the type of Mutex to use (Mutex or NoMutex - the default).
// The Pop() was best done with two functions: Pop() and TryPop().
// Warning! Don't mix-n-match calls to these! One type of Queue should only use one type of Pop()!
//

#ifndef Queue_tt
#define Queue_tt

#include "Semaphore.hh"
#include "Mutex.Lock.hh"
#include "NoMutex.Lock.hh"

class MT::_Queue_ : private _Template_ {
protected:
   class _Node_;
}; // _Queue_

template <typename Element, class Mutex=MT::NoMutex, class Lock=MT::NoMutex::Lock>
class MT::Queue : private _Queue_ {

public: // Methods

   Queue();

   inline unsigned Count() const;

   bool Push(Element &element);

   // Returns nullptr if nothing on Queue
   Element *TryPop();

   // Waits until there's something to Pop
   Element &Pop();

   ~Queue();

private: // Classes

   class Node; friend Node;

private: // Methods

   Queue(const Queue &) = delete;

   Element *Get();

private: // Variables

   Mutex mutex;

   MT::Semaphore semaphore;

   Node *head;

   Node *tail;

   unsigned count;

}; // Queue

#include "Queue.Node.ii"

template <typename Element, class Mutex, class Lock>
MT::Queue<Element,Mutex,Lock>::Queue() :
                               mutex(),
                               semaphore(),
                               head(nullptr),
                               tail(nullptr),
                               count(0) {
} // Queue::Queue()

template <typename Element, class Mutex, class Lock>
inline unsigned MT::Queue<Element,Mutex,Lock>::Count() const {
   return count;
} // Queue::Count()

template <typename Element, class Mutex, class Lock>
bool MT::Queue<Element,Mutex,Lock>::Push(Element &element) {
   Node *node = new Node(element);
   if (node==nullptr) {
      return false;
   } // if
   {
      Lock lock(mutex);
      if (head==nullptr) {
         head = node;
      } // if
      if (tail!=nullptr) {
         tail->next = node;
      } // if
      tail = node;
      ++count;
   }
   semaphore.Post();
   return true;
} // Queue::Push(element)

template <typename Element, class Mutex, class Lock>
Element *MT::Queue<Element,Mutex,Lock>::TryPop() {
   return semaphore.Try() ?
          Get() :
          nullptr;
} // Queue::TryPop()

template <typename Element, class Mutex, class Lock>
Element &MT::Queue<Element,Mutex,Lock>::Pop() {
   semaphore.Wait();
   return *Get(); // !!!
} // Queue::Pop()

template <typename Element, class Mutex, class Lock>
Element *MT::Queue<Element,Mutex,Lock>::Get() {
   Node *node;
   {
      Lock lock(mutex);
      node = head;
      if (node==nullptr) {
         return nullptr;
      } // if
      head = node->next;
      if (head==nullptr) {
         tail = nullptr;
      } // if
      --count;
   }
   return &node->element;
} // Queue::Get()

template <typename Element, class Mutex, class Lock>
MT::Queue<Element,Mutex,Lock>::~Queue() {
   Lock lock(mutex);
   while (head!=nullptr) {
      TryPop();
   } // while
} // Queue::~Queue()

#endif // Queue_tt
