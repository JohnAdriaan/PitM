//
// List.tt
//

#ifndef List_tt
#define List_tt

#include "General.hh"

class _List_ : private _Template_ {
protected: // Classes
   class _Node_;
}; // _List_

class _List_::_Node_ : private _List_ {
}; // _List_::_Node

template <typename Element>
class List : private _List_ {

public: // Classes

   class Node; friend Node;

public: // Methods

   explicit List(Node Element::*node);

   inline unsigned Count() const;

   Element *Head() const;

   Element *Next(Element *element) const;

   ~List();

private: // Variables

   Node Element::*node;

   Element *head;

   Element *tail;

   unsigned count;

}; // List

template<typename Element>
class List<Element>::Node : private List::_Node_ {

   friend List;

public: // Methods

   Node(List &list, Element &element);

   ~Node();

private: // Variables

   List &list;

   Element &element;

   Element *next;

   Element *prev;

}; // List::Node

template <typename Element>
List<Element>::Node::Node(List &list, Element &element) :
                     list(list),
                     element(element),
                     next(nullptr),
                     prev(list.tail) {
   if (list.head==nullptr) {
      list.head = &element;
   } // if
   if (list.tail!=nullptr) {
      (list.tail->*(list.node)).next = &element;
   } // if
   list.tail = &element;
   ++list.count;
} // Node::Node(List, Element)

template <typename Element>
List<Element>::Node::~Node() {
   if (prev!=nullptr) {
      (prev->*(list.node)).next = next;
   } // if
   if (next!=nullptr) {
      (next->*(list.node)).prev = prev;
   } // if
   if (list.head==&element) {
      list.head = next;
   } // if
   if (list.tail==&element) {
      list.tail = prev;
   } // if
   --list.count;
} // Node::~Node()

template <typename Element>
List<Element>::List(Node Element::*node) :
               node(node),
               head(nullptr),
               tail(nullptr),
               count(0) {
} // List::List(node)

template <typename Element>
inline unsigned List<Element>::Count() const {
   return count;
} // List::Count()

template <typename Element>
Element *List<Element>::Head() const {
   return head;
} // List::Head()

template <typename Element>
Element *List<Element>::Next(Element *element) const {
   if (element==nullptr) {
      return nullptr; // Don't start again: that'd loop!
   } // if
   return (element->*node).next;
} // List::Next(Element)

template <typename Element>
List<Element>::~List() {
   while (head!=nullptr) {
      delete head;
   } // while
} // List::~List()

#endif // List_hh
